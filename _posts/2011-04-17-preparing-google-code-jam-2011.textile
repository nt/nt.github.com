---
layout: post
title: Se préparer au Google Code Jam 2011
published: false
---

h1. {{ page.title }}

p(meta). le - Paris

Le google code jam est une compétition qui rassemble les passionés d'algorithmique pour s'affronter pendant un mois. La compétition de fait en ?? tours et la difficulté progresse de façon exponetielle.

h2. Comment se préparer ?

Il faut se préparer. Le site web TopCoder qui organise ce genre de compétition a "quelques articles":http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index bien faits sur les problèmes type, structures de données et autres difficultés de ce genre de compétition.

Je recommande également de préparer du code. En effet le format des fichiers d'entrée ainsi que le format des fichiers de sortie est classique. S'entrainer et améliorer ensuite cette bibliothèque en faisant les "problèmes des années précédentes":http://code.google.com/codejam/. J'ai fait ce travail en "java":https://github.com/nt/code-jam-io et Walid en "scala":https://github.com/walidk/code-jam.

h2. Making Chess Boards

"Making Chess Boards":http://code.google.com/codejam/contest/dashboard?c=619102#s=p2 est extrait du round 1C de l'an dernier. Il est intéressant car il porte plusieures difficultés représentatives des compétions d'algo. En revanche pour commencé votre entrainement, ce n'est pas l'idéal, je recommande plutôt "le menu":/http://code.google.com/codejam/contests.html.

p=. !http://code.google.com/codejam/contest/images/?image=mcb.png&p=563116&c=619102!

L'objectif est de ....

Explication de la solution..

h3. La programmation dynamique

La programmation dynaique est un outils classique du participant. Ce terme ambigu[1] cache en fait une utilisation intelligente de la mémoisation ()

{% highlight java %}
void calculateCorner() {
  for(int i=1; i < M; i++) {
    for(int j=1; j< N; j++) {
      if(table[i][j] ^ table[i-1][j-1]) corner[i][j] = 1;
      corner[i][j] = min(corner[i-1][j-1]+1, min(left[i][j], top[i][j]));
    }
  }
}
{% endhighlight %}

h3. Suite et fin du problème

Il faut ensuite trouver le plus grand board, lors de l'entrainement nous pensions pouvoir bruteforcer[2] cette recherche, or comme le souligne le "compte rendu":http://code.google.com/codejam/contest/dashboard?c=619102#s=a&a=2, nous avions mal estimé le temps requis. 

Il faut donc avoir les bon réflexes et utiliser une "queue prioritaire":http://en.wikipedia.org/wiki/Priority_queue que nous devons remplir avec tous les tableaux disponibles ...



----

fn1. Le terme "dynamic programming" a été choisi car . Lisez l'histoire "ici":http://arcanesentiment.blogspot.com/2010/04/why-dynamic-programming.html et sur Google.

fn2. Calculer sans finesse ni rafinement. En compétition c'est intéressant si réalisable car fournit une solution sans réfléchir.